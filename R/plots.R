# R/plots.R
# Plotting functions for heat pulse data visualisation

#' @importFrom dplyr %>% filter select mutate
#' @importFrom patchwork plot_annotation plot_layout
NULL

#' Plot Heat Pulse Trace with Calculation Windows
#'
#' Creates a diagnostic plot showing temperature traces for a single heat pulse
#' with calculation windows and timepoints overlaid for different methods.
#'
#' @param heat_pulse_data A heat_pulse_data object from read_heat_pulse_data()
#' @param vh_results Results tibble from calc_heat_pulse_velocity()
#' @param pulse_id Pulse ID to plot
#' @param show_methods Character vector of methods to show windows for.
#'   If NULL, shows all methods present in results. Default: NULL
#' @param pre_pulse Number of seconds of pre-pulse data to show. Default: 30
#'
#' @return A ggplot2 object
#'
#' @examples
#' \dontrun{
#' heat_pulse_data <- read_heat_pulse_data("data.txt")
#' results <- calc_heat_pulse_velocity(heat_pulse_data)
#' plot_heat_pulse_trace(heat_pulse_data, results, pulse_id = 1)
#'
#' # Show only specific methods
#' plot_heat_pulse_trace(heat_pulse_data, results, pulse_id = 1,
#'                       show_methods = c("HRM", "Tmax_Coh"))
#' }
#'
#' @export
plot_heat_pulse_trace <- function(heat_pulse_data,
                                   vh_results,
                                   pulse_id,
                                   show_methods = NULL,
                                   pre_pulse = 30) {

  # Check required packages
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required. Install with: install.packages('ggplot2')")
  }
  if (!requireNamespace("tidyr", quietly = TRUE)) {
    stop("Package 'tidyr' is required. Install with: install.packages('tidyr')")
  }

  # Validate inputs
  if (!inherits(heat_pulse_data, "heat_pulse_data")) {
    stop("heat_pulse_data must be a heat_pulse_data object from read_heat_pulse_data()")
  }
  if (!inherits(vh_results, "vh_results")) {
    stop("vh_results must be results from calc_heat_pulse_velocity()")
  }

  # Extract pulse data
  pulse_data <- heat_pulse_data$measurements[heat_pulse_data$measurements$pulse_id == pulse_id, ]

  if (nrow(pulse_data) == 0) {
    stop("Pulse ID ", pulse_id, " not found in heat_pulse_data")
  }

  # Calculate time relative to pulse (seconds)
  pulse_data$time_sec <- seq_len(nrow(pulse_data)) - pre_pulse

  # Calculate baseline temperatures
  pre_pulse_period <- 1:min(pre_pulse, nrow(pulse_data))
  do_baseline <- mean(pulse_data$do[pre_pulse_period], na.rm = TRUE)
  di_baseline <- mean(pulse_data$di[pre_pulse_period], na.rm = TRUE)
  uo_baseline <- mean(pulse_data$uo[pre_pulse_period], na.rm = TRUE)
  ui_baseline <- mean(pulse_data$ui[pre_pulse_period], na.rm = TRUE)

  # Calculate delta temperatures
  pulse_data$deltaT_do <- pulse_data$do - do_baseline
  pulse_data$deltaT_di <- pulse_data$di - di_baseline
  pulse_data$deltaT_uo <- pulse_data$uo - uo_baseline
  pulse_data$deltaT_ui <- pulse_data$ui - ui_baseline

  # Reshape to long format for ggplot
  plot_data <- tidyr::pivot_longer(
    pulse_data,
    cols = c(deltaT_do, deltaT_di, deltaT_uo, deltaT_ui),
    names_to = "sensor",
    values_to = "deltaT",
    names_prefix = "deltaT_"
  )

  # Create sensor labels
  plot_data$sensor_label <- factor(
    plot_data$sensor,
    levels = c("do", "di", "uo", "ui"),
    labels = c("Downstream Outer (do)", "Downstream Inner (di)",
               "Upstream Outer (uo)", "Upstream Inner (ui)")
  )

  # Get calculation metadata for this pulse
  pulse_results <- vh_results[vh_results$pulse_id == pulse_id, ]

  if (nrow(pulse_results) == 0) {
    warning("No results found for pulse ID ", pulse_id, " in vh_results")
  }

  # Filter methods if specified
  if (!is.null(show_methods)) {
    pulse_results <- pulse_results[pulse_results$method %in% show_methods, ]
  }

  # Create base plot
  p <- ggplot2::ggplot(plot_data, ggplot2::aes(x = time_sec, y = deltaT, color = sensor_label)) +
    ggplot2::geom_line(linewidth = 0.8) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed", color = "black", linewidth = 0.5) +
    ggplot2::annotate("text", x = 0, y = max(plot_data$deltaT, na.rm = TRUE) * 0.95,
                      label = "Heat Pulse", hjust = -0.1, size = 3) +
    ggplot2::scale_color_manual(
      values = c("Downstream Outer (do)" = "#E31A1C",
                 "Downstream Inner (di)" = "#FB9A99",
                 "Upstream Outer (uo)" = "#1F78B4",
                 "Upstream Inner (ui)" = "#A6CEE3")
    ) +
    ggplot2::labs(
      title = paste0("Heat Pulse Trace - Pulse ID: ", pulse_id),
      x = "Time (seconds after pulse)",
      y = expression(paste(Delta, "T (\u00B0C)")),
      color = "Sensor"
    ) +
    ggplot2::theme_classic() +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      legend.position = "bottom",
      panel.grid.minor = ggplot2::element_blank()
    )

  # Add calculation windows and timepoints
  if (nrow(pulse_results) > 0) {
    methods_to_annotate <- unique(pulse_results$method)
    y_max <- max(plot_data$deltaT, na.rm = TRUE)
    annotation_y_offset <- 0

    for (method in methods_to_annotate) {
      method_data <- pulse_results[pulse_results$method == method & pulse_results$sensor_position == "outer", ]

      if (nrow(method_data) == 0) next

      # Add windowed methods (HRM, HRMXa, HRMXb)
      if (!is.na(method_data$calc_window_start_sec[1]) && !is.na(method_data$calc_window_end_sec[1])) {
        window_start <- method_data$calc_window_start_sec[1]
        window_end <- method_data$calc_window_end_sec[1]

        p <- p +
          ggplot2::annotate("rect",
                            xmin = window_start, xmax = window_end,
                            ymin = -Inf, ymax = Inf,
                            fill = "grey60", alpha = 0.2) +
          ggplot2::annotate("text",
                            x = (window_start + window_end) / 2,
                            y = y_max * (0.85 - annotation_y_offset * 0.05),
                            label = paste0(method, " window"),
                            size = 3, fontface = "bold")

        annotation_y_offset <- annotation_y_offset + 1
      }

      # Add point methods (Tmax, MHR)
      if (!is.na(method_data$calc_time_sec[1])) {
        calc_time <- method_data$calc_time_sec[1]

        # Find the deltaT value at this time for the downstream outer sensor
        temp_at_calc <- plot_data$deltaT[plot_data$time_sec == calc_time &
                                           plot_data$sensor == "do"]
        if (length(temp_at_calc) > 0) {
          temp_at_calc <- temp_at_calc[1]
        } else {
          temp_at_calc <- 0
        }

        # Create label - use unicode for delta and subscripts
        if (grepl("Tmax", method)) {
          label_text <- paste0("\u0394T", "\u2098", "\u2090", "\u2093")  # Î”Tmax
        } else {
          label_text <- method
        }

        p <- p +
          ggplot2::annotate("segment",
                            x = calc_time, xend = calc_time,
                            y = 0, yend = temp_at_calc,
                            linetype = "dashed", color = "darkgreen", linewidth = 0.7) +
          ggplot2::annotate("point",
                            x = calc_time, y = temp_at_calc,
                            size = 3, color = "darkgreen") +
          ggplot2::annotate("text",
                            x = calc_time,
                            y = temp_at_calc * 1.08,
                            label = label_text,
                            size = 3, fontface = "bold",
                            color = "darkgreen")
      }
    }
  }

  return(p)
}

#' Plot Heat Pulse Trace - Multi-Method Panel
#'
#' Creates a 2x2 panel plot showing heat pulse traces for up to 4 methods,
#' with a shared title and legend. Each panel shows the calculation window
#' for that specific method.
#'
#' @param heat_pulse_data A heat_pulse_data object from read_heat_pulse_data()
#' @param vh_results Results tibble from calc_heat_pulse_velocity()
#' @param pulse_id Pulse ID to plot
#' @param methods Character vector of exactly 4 methods to show (one per panel).
#'   Default: c("HRM", "MHR", "HRMXa", "Tmax_Klu")
#' @param pre_pulse Number of seconds of pre-pulse data to show. Default: 30
#'
#' @return A patchwork object with 4 panels
#'
#' @examples
#' \dontrun{
#' heat_pulse_data <- read_heat_pulse_data("data.txt")
#' results <- calc_heat_pulse_velocity(heat_pulse_data,
#'                                      methods = c("HRM", "MHR", "HRMXa", "Tmax_Klu"))
#'
#' # Create 2x2 panel plot
#' plot_heat_pulse_trace_multi(heat_pulse_data, results, pulse_id = 1)
#'
#' # Specify different methods
#' plot_heat_pulse_trace_multi(heat_pulse_data, results, pulse_id = 1,
#'                             methods = c("HRM", "HRMXa", "HRMXb", "Tmax_Coh"))
#' }
#'
#' @export
plot_heat_pulse_trace_multi <- function(heat_pulse_data,
                                        vh_results,
                                        pulse_id,
                                        methods = c("HRM", "MHR", "HRMXa", "Tmax_Klu"),
                                        pre_pulse = 30) {

  # Check required packages
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required. Install with: install.packages('ggplot2')")
  }
  if (!requireNamespace("tidyr", quietly = TRUE)) {
    stop("Package 'tidyr' is required. Install with: install.packages('tidyr')")
  }
  if (!requireNamespace("patchwork", quietly = TRUE)) {
    stop("Package 'patchwork' is required. Install with: install.packages('patchwork')")
  }

  # Validate inputs
  if (!inherits(heat_pulse_data, "heat_pulse_data")) {
    stop("heat_pulse_data must be a heat_pulse_data object from read_heat_pulse_data()")
  }
  if (!inherits(vh_results, "vh_results")) {
    stop("vh_results must be results from calc_heat_pulse_velocity()")
  }

  if (length(methods) != 4) {
    stop("Exactly 4 methods required for 2x2 panel plot. Provided: ", length(methods))
  }

  # Extract pulse data
  pulse_data <- heat_pulse_data$measurements[heat_pulse_data$measurements$pulse_id == pulse_id, ]

  if (nrow(pulse_data) == 0) {
    stop("Pulse ID ", pulse_id, " not found in heat_pulse_data")
  }

  # Calculate time relative to pulse (seconds)
  pulse_data$time_sec <- seq_len(nrow(pulse_data)) - pre_pulse

  # Calculate baseline temperatures
  pre_pulse_period <- 1:min(pre_pulse, nrow(pulse_data))
  do_baseline <- mean(pulse_data$do[pre_pulse_period], na.rm = TRUE)
  di_baseline <- mean(pulse_data$di[pre_pulse_period], na.rm = TRUE)
  uo_baseline <- mean(pulse_data$uo[pre_pulse_period], na.rm = TRUE)
  ui_baseline <- mean(pulse_data$ui[pre_pulse_period], na.rm = TRUE)

  # Calculate delta temperatures
  pulse_data$deltaT_do <- pulse_data$do - do_baseline
  pulse_data$deltaT_di <- pulse_data$di - di_baseline
  pulse_data$deltaT_uo <- pulse_data$uo - uo_baseline
  pulse_data$deltaT_ui <- pulse_data$ui - ui_baseline

  # Reshape to long format for ggplot
  plot_data <- tidyr::pivot_longer(
    pulse_data,
    cols = c(deltaT_do, deltaT_di, deltaT_uo, deltaT_ui),
    names_to = "sensor",
    values_to = "deltaT",
    names_prefix = "deltaT_"
  )

  # Create sensor labels
  plot_data$sensor_label <- factor(
    plot_data$sensor,
    levels = c("do", "di", "uo", "ui"),
    labels = c("Downstream Outer (do)", "Downstream Inner (di)",
               "Upstream Outer (uo)", "Upstream Inner (ui)")
  )

  # Get calculation metadata for this pulse
  pulse_results <- vh_results[vh_results$pulse_id == pulse_id, ]

  if (nrow(pulse_results) == 0) {
    warning("No results found for pulse ID ", pulse_id, " in vh_results")
  }

  # Get y-axis range for consistent scaling
  y_max <- max(plot_data$deltaT, na.rm = TRUE)
  y_min <- min(plot_data$deltaT, na.rm = TRUE)

  # Create individual plots for each method
  plot_list <- list()

  for (i in seq_along(methods)) {
    method <- methods[i]

    # Create base plot (without title/legend for individual panels)
    p <- ggplot2::ggplot(plot_data, ggplot2::aes(x = time_sec, y = deltaT, color = sensor_label)) +
      ggplot2::geom_line(linewidth = 0.8) +
      ggplot2::geom_vline(xintercept = 0, linetype = "dashed", color = "black", linewidth = 0.5) +
      ggplot2::scale_color_manual(
        values = c("Downstream Outer (do)" = "#E31A1C",
                   "Downstream Inner (di)" = "#FB9A99",
                   "Upstream Outer (uo)" = "#1F78B4",
                   "Upstream Inner (ui)" = "#A6CEE3")
      ) +
      ggplot2::labs(
        title = method,
        x = if (i %in% c(3, 4)) "Time (seconds after pulse)" else "",
        y = if (i %in% c(1, 3)) expression(paste(Delta, "T (\u00B0C)")) else "",
        color = "Sensor"
      ) +
      ggplot2::ylim(y_min, y_max) +
      ggplot2::theme_classic() +
      ggplot2::theme(
        plot.title = ggplot2::element_text(face = "bold", size = 12, hjust = 0.5),
        legend.position = "none",
        panel.grid.minor = ggplot2::element_blank(),
        axis.title.x = ggplot2::element_text(size = 10),
        axis.title.y = ggplot2::element_text(size = 10)
      )

    # Add method-specific calculation windows
    method_data <- pulse_results[pulse_results$method == method & pulse_results$sensor_position == "outer", ]

    if (nrow(method_data) > 0) {
      # Add windowed methods (HRM, HRMXa, HRMXb)
      if (!is.na(method_data$calc_window_start_sec[1]) && !is.na(method_data$calc_window_end_sec[1])) {
        window_start <- method_data$calc_window_start_sec[1]
        window_end <- method_data$calc_window_end_sec[1]

        p <- p +
          ggplot2::annotate("rect",
                            xmin = window_start, xmax = window_end,
                            ymin = -Inf, ymax = Inf,
                            fill = "grey60", alpha = 0.2)
      }

      # Add point methods (Tmax, MHR)
      if (!is.na(method_data$calc_time_sec[1])) {
        calc_time <- method_data$calc_time_sec[1]

        # Find the deltaT value at this time for the downstream outer sensor
        temp_at_calc <- plot_data$deltaT[plot_data$time_sec == calc_time &
                                           plot_data$sensor == "do"]
        if (length(temp_at_calc) > 0) {
          temp_at_calc <- temp_at_calc[1]
        } else {
          temp_at_calc <- 0
        }

        p <- p +
          ggplot2::annotate("segment",
                            x = calc_time, xend = calc_time,
                            y = 0, yend = temp_at_calc,
                            linetype = "dashed", color = "darkgreen", linewidth = 0.7) +
          ggplot2::annotate("point",
                            x = calc_time, y = temp_at_calc,
                            size = 3, color = "darkgreen")
      }
    }

    plot_list[[i]] <- p
  }

  # Create a dummy plot to extract legend
  legend_plot <- ggplot2::ggplot(plot_data, ggplot2::aes(x = time_sec, y = deltaT, color = sensor_label)) +
    ggplot2::geom_line() +
    ggplot2::scale_color_manual(
      values = c("Downstream Outer (do)" = "#E31A1C",
                 "Downstream Inner (di)" = "#FB9A99",
                 "Upstream Outer (uo)" = "#1F78B4",
                 "Upstream Inner (ui)" = "#A6CEE3")
    ) +
    ggplot2::labs(color = "Sensor") +
    ggplot2::theme_classic() +
    ggplot2::theme(
      legend.position = "bottom",
      legend.title = ggplot2::element_text(face = "bold", size = 10),
      legend.direction = "horizontal"
    )

  # Combine plots in 2x2 grid with patchwork, using guide_area for legend
  final_plot <- (plot_list[[1]] | plot_list[[2]]) /
                (plot_list[[3]] | plot_list[[4]]) /
                patchwork::guide_area() +
    patchwork::plot_layout(
      heights = c(10, 10, 1),
      guides = "collect"
    ) +
    patchwork::plot_annotation(
      title = paste0("Heat Pulse Trace - Pulse ID: ", pulse_id),
      theme = ggplot2::theme(
        plot.title = ggplot2::element_text(face = "bold", size = 14, hjust = 0.5)
      )
    ) &
    ggplot2::theme(
      legend.position = "bottom",
      legend.direction = "horizontal"
    )

  return(final_plot)
}


#' Plot Heat Pulse Velocity Time Series
#'
#' Creates a time series plot of heat pulse velocity calculated by different methods.
#' Provides interactive prompts if dates or methods are not specified.
#'
#' @param vh_results Results tibble from calc_heat_pulse_velocity()
#' @param start_date Start date/datetime (POSIXct) or numeric day number.
#'   If NULL, prompts user. Default: NULL
#' @param end_date End date/datetime (POSIXct) or numeric (days to plot from start).
#'   If NULL, prompts user. Default: NULL
#' @param methods Character vector of methods to plot. If NULL, prompts user or uses all.
#'   Default: NULL
#' @param sensor_position Sensor position to plot: "inner" or "outer". Default: "outer"
#' @param quality_filter Logical indicating whether to filter to "OK" quality only.
#'   Default: TRUE
#'
#' @return A ggplot2 object
#'
#' @examples
#' \dontrun{
#' # Interactive mode - will prompt for dates and methods
#' plot_vh_timeseries(results)
#'
#' # Specify everything
#' plot_vh_timeseries(results,
#'                    start_date = as.POSIXct("2025-09-11"),
#'                    end_date = as.POSIXct("2025-09-18"),
#'                    methods = c("HRM", "MHR"),
#'                    sensor_position = "outer")
#'
#' # Use day numbers (plot days 7-14)
#' plot_vh_timeseries(results, start_date = 7, end_date = 14)
#'
#' # Start from day 7, plot 7 days
#' plot_vh_timeseries(results, start_date = 7, end_date = 7)
#' }
#'
#' @export
plot_vh_timeseries <- function(vh_results,
                               start_date = NULL,
                               end_date = NULL,
                               methods = NULL,
                               sensor_position = "outer",
                               quality_filter = TRUE) {

  # Check required packages
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required. Install with: install.packages('ggplot2')")
  }
  if (!requireNamespace("dplyr", quietly = TRUE)) {
    stop("Package 'dplyr' is required. Install with: install.packages('dplyr')")
  }

  # Validate inputs
  if (!inherits(vh_results, "vh_results") && !inherits(vh_results, "data.frame")) {
    stop("vh_results must be a results tibble from calc_heat_pulse_velocity()")
  }

  if (!sensor_position %in% c("inner", "outer")) {
    stop("sensor_position must be 'inner' or 'outer'")
  }

  # Get date range from data
  data_start <- min(vh_results$datetime, na.rm = TRUE)
  data_end <- max(vh_results$datetime, na.rm = TRUE)
  total_days <- as.numeric(difftime(data_end, data_start, units = "days"))

  # Get available methods
  available_methods <- unique(vh_results$method)

  # Interactive prompts if parameters not specified
  if (is.null(start_date) && interactive()) {
    cat("\n")
    cat(strrep("=", 67), "\n")
    cat(sprintf("You have %.1f days of data\n", total_days))
    cat(sprintf("Start: %s\n", format(data_start, "%Y-%m-%d %H:%M:%S")))
    cat(sprintf("End:   %s\n", format(data_end, "%Y-%m-%d %H:%M:%S")))
    cat(strrep("=", 67), "\n\n")

    cat("Enter start date (YYYY-MM-DD) or day number: ")
    start_input <- readline()

    start_date <- parse_date_input(start_input, data_start)
  } else if (is.null(start_date)) {
    # Non-interactive: use data start
    start_date <- data_start
  } else if (is.numeric(start_date)) {
    # Convert day number to date
    start_date <- data_start + (start_date - 1) * 86400
  }

  if (is.null(end_date) && interactive()) {
    cat("\nEnter end date (YYYY-MM-DD) or number of days to plot: ")
    end_input <- readline()

    end_date <- parse_date_input(end_input, start_date)
  } else if (is.null(end_date)) {
    # Non-interactive: use data end
    end_date <- data_end
  } else if (is.numeric(end_date)) {
    # Convert number of days to end date
    end_date <- start_date + end_date * 86400
  }

  # Validate date range
  if (start_date < data_start || start_date > data_end) {
    stop(sprintf("Start date %s is outside data range [%s to %s]",
                 format(start_date, "%Y-%m-%d"),
                 format(data_start, "%Y-%m-%d"),
                 format(data_end, "%Y-%m-%d")))
  }

  if (end_date < data_start || end_date > data_end) {
    stop(sprintf("End date %s is outside data range [%s to %s]",
                 format(end_date, "%Y-%m-%d"),
                 format(data_start, "%Y-%m-%d"),
                 format(data_end, "%Y-%m-%d")))
  }

  if (end_date <= start_date) {
    stop("End date must be after start date")
  }

  # Select methods interactively if not specified
  if (is.null(methods) && interactive()) {
    cat("\nAvailable methods:\n")
    for (i in seq_along(available_methods)) {
      cat(sprintf("  [%d] %s\n", i, available_methods[i]))
    }
    cat("\nEnter method numbers (comma-separated, e.g., 1,2) or 'all': ")
    method_input <- readline()

    if (tolower(trimws(method_input)) == "all") {
      methods <- available_methods
    } else {
      method_indices <- as.numeric(strsplit(method_input, ",")[[1]])
      method_indices <- method_indices[!is.na(method_indices)]
      if (length(method_indices) == 0) {
        warning("No valid methods selected, using all methods")
        methods <- available_methods
      } else {
        methods <- available_methods[method_indices]
      }
    }
  } else if (is.null(methods)) {
    # Non-interactive: use all methods
    methods <- available_methods
  }

  # Validate methods
  invalid_methods <- setdiff(methods, available_methods)
  if (length(invalid_methods) > 0) {
    stop("Methods not found in data: ", paste(invalid_methods, collapse = ", "),
         "\nAvailable methods: ", paste(available_methods, collapse = ", "))
  }

  # Filter data
  selected_position <- sensor_position  # Avoid variable name shadowing
  filtered_data <- vh_results %>%
    dplyr::filter(
      datetime >= start_date,
      datetime <= end_date,
      method %in% methods,
      sensor_position == selected_position,
      !is.na(Vh_cm_hr)
    )

  # Apply quality filter if requested
  if (quality_filter) {
    filtered_data <- filtered_data %>%
      dplyr::filter(quality_flag == "OK")
  }

  # Check if any data remains
  if (nrow(filtered_data) == 0) {
    stop("No data available after filtering with specified parameters")
  }

  # Create plot
  p <- ggplot2::ggplot(filtered_data, ggplot2::aes(x = datetime, y = Vh_cm_hr, color = method)) +
    ggplot2::geom_line(linewidth = 1) +
    ggplot2::labs(
      title = paste0("Heat Pulse Velocity Time Series: ", sensor_position, " sensor"),
      subtitle = paste0(format(start_date, "%Y-%m-%d"), " to ", format(end_date, "%Y-%m-%d")),
      x = "Date/Time",
      y = expression(paste("V"[h], " cm"^-1, " hr"^-1)),
      color = "Method"
    ) +
    ggplot2::theme_classic() +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 11),
      axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
      legend.position = "bottom"
    )

  # Print summary
  cat("\n")
  cat(strrep("=", 67), "\n")
  cat("PLOT SUMMARY\n")
  cat(strrep("=", 67), "\n")
  cat(sprintf("Date range: %s to %s\n",
              format(start_date, "%Y-%m-%d %H:%M"),
              format(end_date, "%Y-%m-%d %H:%M")))
  cat(sprintf("Duration: %.1f days\n", as.numeric(difftime(end_date, start_date, units = "days"))))
  cat(sprintf("Methods: %s\n", paste(methods, collapse = ", ")))
  cat(sprintf("Sensor position: %s\n", sensor_position))
  cat(sprintf("Data points: %s\n", format(nrow(filtered_data), big.mark = ",")))

  # Show data availability per method
  cat("\nData points per method:\n")
  method_counts <- table(filtered_data$method)
  for (method in names(method_counts)) {
    cat(sprintf("  %-15s: %s\n", method, format(method_counts[method], big.mark = ",")))
  }
  cat(strrep("=", 67), "\n\n")

  return(p)
}


#' Parse Date Input from User
#'
#' Helper function to parse date input which can be a date string or number of days
#'
#' @param input Character string from user input
#' @param reference_date POSIXct reference date for numeric offsets
#' @return POSIXct datetime
#' @keywords internal
parse_date_input <- function(input, reference_date) {
  input <- trimws(input)

  # Try as numeric first (day number or number of days)
  num_input <- suppressWarnings(as.numeric(input))
  if (!is.na(num_input)) {
    return(reference_date + (num_input - 1) * 86400)
  }

  # Try as date string
  parsed_date <- tryCatch({
    as.POSIXct(input)
  }, error = function(e) {
    NULL
  })

  if (!is.null(parsed_date) && !is.na(parsed_date)) {
    return(parsed_date)
  }

  stop("Could not parse date input: ", input,
       "\nExpected format: YYYY-MM-DD or numeric day number")
}


#' Plot Method Comparison Scatter
#'
#' Creates a scatter plot comparing two methods with 1:1 line and correlation.
#'
#' @param vh_results Results tibble from calc_heat_pulse_velocity()
#' @param method1 First method name
#' @param method2 Second method name
#' @param sensor_position Sensor position: "inner" or "outer". Default: "outer"
#' @param quality_filter Logical indicating whether to filter to "OK" quality only.
#'   Default: TRUE
#'
#' @return A ggplot2 object
#'
#' @examples
#' \dontrun{
#' plot_method_comparison(results, "HRM", "MHR")
#' plot_method_comparison(results, "HRM", "Tmax_Coh", sensor_position = "inner")
#' }
#'
#' @export
plot_method_comparison <- function(vh_results,
                                   method1,
                                   method2,
                                   sensor_position = "outer",
                                   quality_filter = TRUE) {

  # Check required packages
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is required. Install with: install.packages('ggplot2')")
  }
  if (!requireNamespace("tidyr", quietly = TRUE)) {
    stop("Package 'tidyr' is required. Install with: install.packages('tidyr')")
  }
  if (!requireNamespace("dplyr", quietly = TRUE)) {
    stop("Package 'dplyr' is required. Install with: install.packages('dplyr')")
  }

  # Validate methods exist
  available_methods <- unique(vh_results$method)
  if (!method1 %in% available_methods) {
    stop("Method '", method1, "' not found in data.\nAvailable: ",
         paste(available_methods, collapse = ", "))
  }
  if (!method2 %in% available_methods) {
    stop("Method '", method2, "' not found in data.\nAvailable: ",
         paste(available_methods, collapse = ", "))
  }

  # Filter and reshape data
  selected_position <- sensor_position  # Avoid variable name shadowing
  filtered_data <- vh_results %>%
    dplyr::filter(
      method %in% c(method1, method2),
      sensor_position == selected_position,
      !is.na(Vh_cm_hr)
    )

  if (quality_filter) {
    filtered_data <- filtered_data %>%
      dplyr::filter(quality_flag == "OK")
  }

  # Reshape to wide format
  wide_data <- filtered_data %>%
    dplyr::select(pulse_id, datetime, method, Vh_cm_hr) %>%
    tidyr::pivot_wider(
      names_from = method,
      values_from = Vh_cm_hr
    ) %>%
    tidyr::drop_na()

  if (nrow(wide_data) == 0) {
    stop("No overlapping data points between ", method1, " and ", method2)
  }

  # Calculate correlation and statistics
  cor_value <- cor(wide_data[[method1]], wide_data[[method2]], use = "complete.obs")
  rmse <- sqrt(mean((wide_data[[method1]] - wide_data[[method2]])^2))
  bias <- mean(wide_data[[method1]] - wide_data[[method2]])

  # Create plot
  axis_max <- max(c(wide_data[[method1]], wide_data[[method2]]), na.rm = TRUE)
  axis_min <- min(c(wide_data[[method1]], wide_data[[method2]]), na.rm = TRUE)

  p <- ggplot2::ggplot(wide_data, ggplot2::aes(x = .data[[method1]], y = .data[[method2]])) +
    ggplot2::geom_point(alpha = 0.5, size = 2) +
    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red", linewidth = 1) +
    ggplot2::geom_smooth(method = "lm", se = TRUE, color = "blue", linewidth = 0.8) +
    ggplot2::coord_equal(xlim = c(axis_min, axis_max), ylim = c(axis_min, axis_max)) +
    ggplot2::annotate("text", x = axis_min + (axis_max - axis_min) * 0.05,
                      y = axis_max - (axis_max - axis_min) * 0.05,
                      label = sprintf("r = %.3f\nRMSE = %.2f cm/hr\nBias = %.2f cm/hr\nn = %d",
                                      cor_value, rmse, bias, nrow(wide_data)),
                      hjust = 0, vjust = 1, size = 4) +
    ggplot2::labs(
      title = paste0("Method Comparison: ", method1, " vs ", method2),
      subtitle = paste0(sensor_position, " sensor"),
      x = paste0(method1, " (cm/hr)"),
      y = paste0(method2, " (cm/hr)")
    ) +
    ggplot2::theme_classic() +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 11)
    )

  return(p)
}
